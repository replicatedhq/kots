name: build-test

on:
  pull_request:
  # pull_request_target:
  #   # This workflow trigger may lead to malicious PR authors being able to obtain repository write permissions or stealing repository secrets.
  #   # Please read https://securitylab.github.com/research/github-actions-preventing-pwn-requests/
  #   types: [ opened, synchronize, reopened, labeled ]

concurrency:
  group: ${{ github.head_ref }}
  cancel-in-progress: true

jobs:
  can-run-ci:
    runs-on: ubuntu-20.04
    # if the event is pull_request and:
    #   - it is not a fork OR it is from the dependabot
    #   - Then must have the label '@actions/safe-to-test'
    #
    # The 'pull_request_target' workflow trigger may lead to malicious PR authors being able to obtain repository write permissions or stealing repository secrets.
    # Please read https://securitylab.github.com/research/github-actions-preventing-pwn-requests/
    if: >
      ( github.event_name == 'pull_request' &&
        ( github.event.pull_request.head.repo.full_name == github.repository ||
          contains(github.event.pull_request.labels.*.name, '@actions/safe-to-test' ) 
        )
      )
    steps:
      - name: ok
        run: echo "yes"

  # Use this to disable tests when iteratig on a specific test to save time
  enable-tests:
    runs-on: ubuntu-20.04
    steps:
      - name: ok
        # change 0 to a positive interger to prevent all tests from running
        run: exit 0


  generate-tag:
    runs-on: ubuntu-20.04
    outputs:
      tag: ${{ steps.get_tag.outputs.GIT_TAG }}
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Get tags
        id: get_tag
        uses: ./.github/actions/version-tag


  test-okteto-env:
    runs-on: ubuntu-latest
    needs: [ can-run-ci ]
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Test Okteto development environment
        uses: replicatedhq/action-okteto-test@main
        with:
          token: ${{ secrets.OKTETO_TOKEN }}
          branch: ${{ github.head_ref }}


  build-web:
    runs-on: ubuntu-20.04
    needs: [ can-run-ci, generate-tag ]
    steps:
      # This workflow trigger may lead to malicious PR authors being able to obtain repository write permissions or stealing repository secrets.
      # Please read https://securitylab.github.com/research/github-actions-preventing-pwn-requests/
      # this action checks out the remote branch and runs CI
      - name: Checkout
        uses: actions/checkout@v2
        with:
          ref: ${{github.event.pull_request.head.ref}}
          repository: ${{github.event.pull_request.head.repo.full_name}}

      - name: Setup Node.js environment
        uses: actions/setup-node@v2
        with:
          node-version: '17.x'

      - name: Build web
        env:
          GIT_TAG: ${{ needs.generate-tag.outputs.tag }}
        run: export $(cat .image.env | sed 's/#.*//g' | xargs) && make -C web deps lint test-unit build-kotsadm

      - name: Upload web artifact
        uses: actions/upload-artifact@v2
        with:
          name: web
          path: ./web/dist


  build-kots:
    runs-on: ubuntu-20.04
    needs: [ can-run-ci, build-web, generate-tag ]

    steps:
      - uses: actions/setup-go@v2
        with:
          go-version: '^1.19.2'

      - name: setup env
        run: |
          echo "GOPATH=$(go env GOPATH)" >> $GITHUB_ENV
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH
        shell: bash

      # This workflow trigger may lead to malicious PR authors being able to obtain repository write permissions or stealing repository secrets.
      # Please read https://securitylab.github.com/research/github-actions-preventing-pwn-requests/
      # this action checks out the remote branch and runs CI
      - uses: actions/checkout@v2
        with:
          ref: ${{github.event.pull_request.head.ref}}
          repository: ${{github.event.pull_request.head.repo.full_name}}

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-kots-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-kots-

      - name: Download web artifact
        uses: actions/download-artifact@v2
        with:
          name: web
          path: ./web/dist
      - name: Build kots
        env:
          GIT_TAG: ${{ needs.generate-tag.outputs.tag }}
        run: export $(cat .image.env | sed 's/#.*//g' | xargs) && make vet ci-test kots build
      - uses: actions/upload-artifact@v2
        with:
          name: kots
          path: bin/kots
      - name: build and push kotsadm for e2e
        uses: docker/build-push-action@v2
        with:
          tags: ttl.sh/automated-${{ github.run_id }}/kotsadm:12h
          context: ./
          file: ./deploy/Dockerfile
          push: true


  build-kots-helm:
    runs-on: ubuntu-20.04
    needs: [ can-run-ci ]

    steps:
      - uses: actions/checkout@v2
        with:
          ref: main
          repository: replicatedhq/kots-helm

      - name: Build KOTS Helm chart
        env:
          GIT_COMMIT: ${{ github.sha }}
        run: |
          curl -O -L https://raw.githubusercontent.com/replicatedhq/kots/${GIT_COMMIT}/.image.env
          export $(cat .image.env | sed 's/#.*//g' | xargs)

          export CHART_VERSION=0.0.${{ github.run_id }}-automated
          export KOTS_VERSION=12h
          export KOTS_TAG=12h
          export KOTSADM_REGISTRY=ttl.sh/automated-${{ github.run_id }}

          envsubst < Chart.yaml.tmpl > Chart.yaml
          envsubst < values.yaml.tmpl > values.yaml

          export CHART_NAME=`helm package . | rev | cut -d/ -f1 | rev`
          helm push $CHART_NAME oci://ttl.sh/automated-${{ github.run_id }}


  build-e2e:
    runs-on: ubuntu-20.04
    needs: [ can-run-ci ]
    steps:
      - uses: actions/setup-go@v2
        with:
          go-version: '^1.19.2'

      - uses: actions/checkout@v2
        with:
          ref: ${{github.event.pull_request.head.ref}}
          repository: ${{github.event.pull_request.head.repo.full_name}}

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-e2e-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-e2e-
      - run: make -C e2e build deps
      - run: docker save e2e-deps -o e2e/bin/e2e-deps.tar
      - uses: actions/upload-artifact@v2
        with:
          name: e2e
          path: e2e/bin/


  build-kurl-proxy:
    runs-on: ubuntu-20.04
    needs: [ can-run-ci ]
    steps:
      - uses: actions/setup-go@v2
        with:
          go-version: '^1.19.2'

      - name: setup env
        run: |
          echo "GOPATH=$(go env GOPATH)" >> $GITHUB_ENV
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH
        shell: bash

      # This workflow trigger may lead to malicious PR authors being able to obtain repository write permissions or stealing repository secrets.
      # Please read https://securitylab.github.com/research/github-actions-preventing-pwn-requests/
      # this action creates a branch based on remote branch and runs the tests
      - uses: actions/checkout@v2
        with:
          ref: ${{github.event.pull_request.head.ref}}
          repository: ${{github.event.pull_request.head.repo.full_name}}

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-kurlproxy-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-kurlproxy-

      - run: export $(cat .image.env | sed 's/#.*//g' | xargs) && make -C kurl_proxy test build

      - name: build and push kurl_proxy for e2e
        uses: docker/build-push-action@v2
        with:
          tags: ttl.sh/automated-${{ github.run_id }}/kurl-proxy:12h
          context: ./kurl_proxy
          file: ./kurl_proxy/deploy/Dockerfile
          push: true


  build-migrations:
    runs-on: ubuntu-20.04
    needs: [ can-run-ci ]
    steps:
      - name: setup env
        run: |
          echo "GOPATH=$(go env GOPATH)" >> $GITHUB_ENV
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH
        shell: bash

      # This workflow trigger may lead to malicious PR authors being able to obtain repository write permissions or stealing repository secrets.
      # Please read https://securitylab.github.com/research/github-actions-preventing-pwn-requests/
      # this action creates a branch based on remote branch and runs the tests
      - uses: actions/checkout@v2
        with:
          ref: ${{github.event.pull_request.head.ref}}
          repository: ${{github.event.pull_request.head.repo.full_name}}

      - name: load environment variables from .image.env
        uses: falti/dotenv-action@v0.2
        id: dotenv
        with:
          path: .image.env

      - name: build and push migrations for e2e
        uses: docker/build-push-action@v2
        with:
          tags: ttl.sh/automated-${{ github.run_id }}/kotsadm-migrations:12h
          context: ./migrations
          file: ./migrations/deploy/Dockerfile
          push: true
          build-args: SCHEMAHERO_TAG=${{ steps.dotenv.outputs.schemahero_tag }}


  push-minio:
    runs-on: ubuntu-20.04
    needs: [ can-run-ci ]
    steps:
      - uses: actions/checkout@v2

      - name: load environment variables from .image.env
        uses: falti/dotenv-action@v0.2
        id: dotenv
        with:
          path: .image.env

      - name: push minio for e2e
        run: |
          docker pull minio/minio:${{ steps.dotenv.outputs.minio_tag }}
          docker tag minio/minio:${{ steps.dotenv.outputs.minio_tag }} ttl.sh/automated-${{ github.run_id }}/minio:${{ steps.dotenv.outputs.minio_tag }}
          docker push ttl.sh/automated-${{ github.run_id }}/minio:${{ steps.dotenv.outputs.minio_tag }}


  push-rqlite:
    runs-on: ubuntu-20.04
    needs: [ can-run-ci ]
    steps:
      - uses: actions/checkout@v2

      - name: load environment variables from .image.env
        uses: falti/dotenv-action@v0.2
        id: dotenv
        with:
          path: .image.env

      - name: push rqlite for CI
        run: |
          docker pull rqlite/rqlite:${{ steps.dotenv.outputs.RQLITE_TAG }}
          docker tag rqlite/rqlite:${{ steps.dotenv.outputs.RQLITE_TAG }} ttl.sh/automated-${{ github.run_id }}/rqlite:${{ steps.dotenv.outputs.RQLITE_TAG }}
          docker push ttl.sh/automated-${{ github.run_id }}/rqlite:${{ steps.dotenv.outputs.RQLITE_TAG }}


  push-dex:
    runs-on: ubuntu-20.04
    needs: [ can-run-ci ]
    steps:
      - uses: actions/checkout@v2

      - name: load environment variables from .image.env
        uses: falti/dotenv-action@v0.2
        id: dotenv
        with:
          path: .image.env

      - name: push dex for CI
        run: |
          docker build --pull -f deploy/dex.Dockerfile -t ttl.sh/automated-${{ github.run_id }}/dex:${{ steps.dotenv.outputs.DEX_TAG }} --build-arg TAG=${{ steps.dotenv.outputs.DEX_TAG }} .
          docker push ttl.sh/automated-${{ github.run_id }}/dex:${{ steps.dotenv.outputs.DEX_TAG }}


  # only run validate-kurl-addon if changes to "deploy/kurl/kotsadm/template/**"
  kurl-addon-changes-filter:
    runs-on: ubuntu-20.04
    needs: [ can-run-ci, enable-tests ]
    outputs:
      ok-to-test: ${{ steps.filter.outputs.kurl-addon }}
    steps:
      - uses: actions/checkout@v2
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            kurl-addon:
              - 'deploy/kurl/kotsadm/template/**'
              - 'deploy/kurl/kotsadm/testgrid-os-spec.yaml'
  validate-kurl-addon:
    runs-on: ubuntu-20.04
    if: ${{ needs.kurl-addon-changes-filter.outputs.ok-to-test == 'true' }}
    needs: [ can-run-ci, enable-tests, generate-tag, kurl-addon-changes-filter, build-kots, build-kurl-proxy, build-migrations, push-dex ]
    steps:
      - name: checkout
        uses: actions/checkout@v2
      - name: set outputs
        id: vars
        run: |
          addon_version=${{ needs.generate-tag.outputs.tag }}
          echo "::set-output name=addon_version::${addon_version#v}"
      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/
      - name: prepare kots binary executable
        run: |
          chmod +x bin/*
          tar -C bin/ -czvf bin/kots.tar.gz kots
      - name: generate kurl add-on
        id: addon-generate
        uses: ./.github/actions/kurl-addon-kots-generate
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.KURL_ADDONS_AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.KURL_ADDONS_AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
        with:
          addon_version: ${{ steps.vars.outputs.addon_version }}
          s3_prefix: ${{ github.event.action == 'workflow_dispatch' && 'test/' || inputs.s3_prefix }}
          kotsadm_image_registry: ttl.sh
          kotsadm_image_namespace: automated-${{ github.run_id }}
          kotsadm_image_tag: 12h
          kotsadm_binary_override: bin/kots.tar.gz
      - name: test kurl add-on
        id: addon-test
        uses: ./.github/actions/kurl-addon-kots-test
        with:
          addon_version: ${{ steps.vars.outputs.addon_version }}
          addon_package_url: ${{ steps.addon-generate.outputs.addon_package_url }}
          priority: ${{ inputs.priority }}
          testgrid_api_token: ${{ secrets.TESTGRID_PROD_API_TOKEN }}
      - name: comment testgrid url
        uses: mshick/add-pr-comment@v1
        with:
          message: ${{ steps.addon-test.outputs.testgrid_run_message }}
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          allow-repeats: false


  validate-existing-online-install-minimal:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-e2e, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: download e2e deps
        uses: actions/download-artifact@v2
        with:
          name: e2e
          path: e2e/bin/
      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/
      - run: |
          docker load -i e2e/bin/e2e-deps.tar
          chmod +x e2e/bin/*
          chmod +x bin/*
      - uses: ./.github/actions/kots-e2e
        with:
          test-focus: 'Regression'
          k8s-version: 'v1.24.4-k3s1'
          testim-branch: ${{ github.head_ref == 'main' && 'master' || github.head_ref }}
          testim-access-token: '${{ secrets.TESTIM_ACCESS_TOKEN }}'
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-smoke-test:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-e2e, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.21.8-k3s2,v1.22.5-k3s2,v1.23.3-k3s1,v1.24.4-k3s1 ]
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: download e2e deps
        uses: actions/download-artifact@v2
        with:
          name: e2e
          path: e2e/bin/
      - run: docker load -i e2e/bin/e2e-deps.tar
      - run: chmod +x e2e/bin/*
      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/
      - run: chmod +x bin/*
      - uses: ./.github/actions/kots-e2e
        with:
          test-focus: 'Smoke Test'
          kots-namespace: 'smoke-test'
          k8s-version: '${{ matrix.k8s_version }}'
          testim-access-token: '${{ secrets.TESTIM_ACCESS_TOKEN }}'
          testim-branch: ${{ github.head_ref == 'main' && 'master' || github.head_ref }}
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-minimal-rbac:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-e2e, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.21.8-k3s2,v1.22.5-k3s2,v1.23.3-k3s1,v1.24.4-k3s1 ]
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: download e2e deps
        uses: actions/download-artifact@v2
        with:
          name: e2e
          path: e2e/bin/
      - run: docker load -i e2e/bin/e2e-deps.tar
      - run: chmod +x e2e/bin/*
      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/
      - run: chmod +x bin/*
      - uses: ./.github/actions/kots-e2e
        with:
          test-focus: 'Minimal RBAC'
          kots-namespace: 'minimal-rbac'
          k8s-version: '${{ matrix.k8s_version }}'
          testim-access-token: '${{ secrets.TESTIM_ACCESS_TOKEN }}'
          testim-branch: ${{ github.head_ref == 'main' && 'master' || github.head_ref }}
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-backup-and-restore:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-e2e, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.21.8-k3s2,v1.22.5-k3s2,v1.23.3-k3s1,v1.24.4-k3s1 ]
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: download e2e deps
        uses: actions/download-artifact@v2
        with:
          name: e2e
          path: e2e/bin/
      - run: docker load -i e2e/bin/e2e-deps.tar
      - run: chmod +x e2e/bin/*
      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/
      - run: chmod +x bin/*
      - uses: ./.github/actions/kots-e2e
        with:
          test-focus: 'Backup and Restore'
          kots-namespace: 'backup-and-restore'
          k8s-version: '${{ matrix.k8s_version }}'
          testim-access-token: '${{ secrets.TESTIM_ACCESS_TOKEN }}'
          testim-branch: ${{ github.head_ref == 'main' && 'master' || github.head_ref }}
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-no-required-config:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-e2e, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.24.4-k3s1 ] # there's no need to run this test on multiple k3s versions
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: download e2e deps
        uses: actions/download-artifact@v2
        with:
          name: e2e
          path: e2e/bin/
      - run: docker load -i e2e/bin/e2e-deps.tar
      - run: chmod +x e2e/bin/*
      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/
      - run: chmod +x bin/*
      - uses: ./.github/actions/kots-e2e
        with:
          test-focus: 'No Required Config'
          kots-namespace: 'no-required-config'
          k8s-version: '${{ matrix.k8s_version }}'
          testim-access-token: '${{ secrets.TESTIM_ACCESS_TOKEN }}'
          testim-branch: ${{ github.head_ref == 'main' && 'master' || github.head_ref }}
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-strict-preflight-checks:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-e2e, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.24.4-k3s1 ] # there's no need to run this test on multiple k3s versions
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: download e2e deps
        uses: actions/download-artifact@v2
        with:
          name: e2e
          path: e2e/bin/
      - run: docker load -i e2e/bin/e2e-deps.tar
      - run: chmod +x e2e/bin/*
      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/
      - run: chmod +x bin/*
      - uses: ./.github/actions/kots-e2e
        with:
          test-focus: 'Strict Preflight Checks'
          kots-namespace: 'strict-preflight-checks'
          k8s-version: '${{ matrix.k8s_version }}'
          testim-access-token: '${{ secrets.TESTIM_ACCESS_TOKEN }}'
          testim-branch: ${{ github.head_ref == 'main' && 'master' || github.head_ref }}
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-version-history-pagination:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-e2e, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.24.4-k3s1 ] # there's no need to run this test on multiple k3s versions
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: download e2e deps
        uses: actions/download-artifact@v2
        with:
          name: e2e
          path: e2e/bin/
      - run: docker load -i e2e/bin/e2e-deps.tar
      - run: chmod +x e2e/bin/*
      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/
      - run: chmod +x bin/*
      - uses: ./.github/actions/kots-e2e
        with:
          test-focus: 'Version History Pagination'
          kots-namespace: 'version-history-pagination'
          k8s-version: '${{ matrix.k8s_version }}'
          testim-access-token: '${{ secrets.TESTIM_ACCESS_TOKEN }}'
          testim-branch: ${{ github.head_ref == 'main' && 'master' || github.head_ref }}
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-change-license:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-e2e, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.24.4-k3s1 ] # there's no need to run this test on multiple k3s versions
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: download e2e deps
        uses: actions/download-artifact@v2
        with:
          name: e2e
          path: e2e/bin/
      - run: docker load -i e2e/bin/e2e-deps.tar
      - run: chmod +x e2e/bin/*
      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/
      - run: chmod +x bin/*
      - uses: ./.github/actions/kots-e2e
        with:
          test-focus: 'Change License'
          kots-namespace: 'change-license'
          k8s-version: '${{ matrix.k8s_version }}'
          testim-access-token: '${{ secrets.TESTIM_ACCESS_TOKEN }}'
          testim-branch: ${{ github.head_ref == 'main' && 'master' || github.head_ref }}
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-helm-managed:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-e2e, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.24.4-k3s1 ] # there's no need to run this test on multiple k3s versions
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: download e2e deps
        uses: actions/download-artifact@v2
        with:
          name: e2e
          path: e2e/bin/
      - run: docker load -i e2e/bin/e2e-deps.tar
      - run: chmod +x e2e/bin/*
      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/
      - run: chmod +x bin/*
      - uses: ./.github/actions/kots-e2e
        with:
          test-focus: 'Helm Managed'
          kots-namespace: 'helm-managed'
          k8s-version: '${{ matrix.k8s_version }}'
          testim-access-token: '${{ secrets.TESTIM_ACCESS_TOKEN }}'
          testim-branch: ${{ github.head_ref == 'main' && 'master' || github.head_ref }}
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'
          kots-helm-chart-url: 'oci://ttl.sh/automated-${{ github.run_id }}/admin-console'
          kots-helm-chart-version: '0.0.${{ github.run_id }}-automated'


  validate-minimal-rbac-override:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.21.8-k3s2,v1.22.5-k3s2,v1.23.3-k3s1,v1.24.4-k3s1 ]
    env:
      APP_SLUG: minimal-rbac
      APP_VERSION_LABEL: "0.0.1"
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - uses: replicatedhq/action-k3s@main
        with:
          version: ${{ matrix.k8s_version }}

      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/

      - run: chmod +x bin/kots

      - name: minimal rbac override on command line
        run: |
          kubectl delete ns $APP_SLUG --ignore-not-found
          ./bin/kots \
            install $APP_SLUG/automated \
            --app-version-label $APP_VERSION_LABEL \
            --no-port-forward \
            --namespace $APP_SLUG \
            --shared-password password \
            --kotsadm-registry ttl.sh \
            --kotsadm-namespace automated-${{ github.run_id }} \
            --kotsadm-tag 12h \
            --use-minimal-rbac
          if kubectl get roles -n $APP_SLUG | grep -q kotsadm; then
            echo "Found kotsadm role in ${APP_SLUG}"
          else
            echo "No kotsadm role found in appication namespace"
            exit -1
          fi
          if kubectl get clusterroles | grep -q kotsadm; then
            echo "Found kotsadm cluster roles in minimal RBAC install"
            exit -1
          fi
      - name: no minimal rbac override on command line
        run: |
          kubectl delete ns $APP_SLUG --ignore-not-found
          ./bin/kots \
            install $APP_SLUG/automated \
            --app-version-label $APP_VERSION_LABEL \
            --no-port-forward \
            --namespace $APP_SLUG \
            --shared-password password \
            --kotsadm-registry ttl.sh \
            --kotsadm-namespace automated-${{ github.run_id }} \
            --kotsadm-tag 12h
          if kubectl get roles -n $APP_SLUG | grep -q kotsadm; then
            echo "Found kotsadm role in cluster scoped install"
            exit -1
          fi
          if kubectl get clusterroles | grep -q kotsadm; then
            echo "Found kotsadm cluster role in cluster scoped install"
          else
            echo "No kotsadm cluster role in cluster scoped install"
            exit -1
          fi
      - name: Generate support bundle on failure
        if: failure()
        uses: ./.github/actions/generate-support-bundle
        with:
          kots-namespace: "$APP_SLUG"
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-multi-namespace:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.21.8-k3s2,v1.22.5-k3s2,v1.23.3-k3s1,v1.24.4-k3s1 ]
    env:
      APP_SLUG: multi-namespace-yeti
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - uses: replicatedhq/action-k3s@main
        with:
          version: ${{ matrix.k8s_version }}

      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/

      - run: chmod +x bin/kots

      - name: run the test
        run: |
          set +e
          echo ${{ secrets.MULTI_NAMESPACE_LICENSE }} | base64 -d > license.yaml
          ./bin/kots \
            install $APP_SLUG/automated \
            --license-file license.yaml \
            --no-port-forward \
            --namespace $APP_SLUG \
            --shared-password password \
            --kotsadm-registry ttl.sh \
            --kotsadm-namespace automated-${{ github.run_id }} \
            --kotsadm-tag 12h

          EXIT_CODE=$?
          if [ $EXIT_CODE -ne 0 ]; then
            echo "------pods:"
            kubectl -n $APP_SLUG get pods
            echo "------kotsadm logs"
            kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
            exit $EXIT_CODE
          fi

          COUNTER=1
          while [ "$(./bin/kots get apps --namespace $APP_SLUG | awk 'NR>1{print $2}')" != "ready" ]; do
            COUNTER=$[$COUNTER +1]
            if [ $COUNTER -gt 120 ]; then
              echo "Timed out waiting for app to be ready"
              ./bin/kots get apps --namespace $APP_SLUG
              echo "kotsadm logs:"
              kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
              exit -1
            fi
            sleep 1
          done

          printf "App is installed successfully and is ready\n\n"
          ./bin/kots get apps --namespace $APP_SLUG

      - name: Generate support bundle on failure
        if: failure()
        uses: ./.github/actions/generate-support-bundle
        with:
          kots-namespace: "$APP_SLUG"
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-kots-pull:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.21.8-k3s2,v1.22.5-k3s2,v1.23.3-k3s1,v1.24.4-k3s1 ]
    env:
      APP_NAME: multi-namespace-yeti
      APP_SLUG: multi-namespace
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - uses: replicatedhq/action-k3s@main
        with:
          version: ${{ matrix.k8s_version }}

      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/

      - run: chmod +x bin/kots

      - name: run kots pull
        run: |
          set +e
          echo ${{ secrets.MULTI_NAMESPACE_LICENSE }} | base64 -d > license.yaml
          ./bin/kots pull $APP_NAME/automated \
            --license-file license.yaml \
            --shared-password password \
            --namespace $APP_NAME \
            --exclude-admin-console

          kubectl create ns $APP_NAME
          kubectl create ns nginx-test
          kubectl create ns redis-test
          kubectl create ns postgres-test

          # HACK: without operator, additonal namespaces don't get image pull secrets
          echo ${{ secrets.MULTI_NAMESPACE_REGISTRY_AUTH }} | base64 -d > replicated-registry-auth.json
          kubectl -n nginx-test create secret generic multi-namespace-yeti-registry --type=kubernetes.io/dockerconfigjson --from-file=.dockerconfigjson=./replicated-registry-auth.json
          kubectl -n redis-test create secret generic multi-namespace-yeti-registry --type=kubernetes.io/dockerconfigjson --from-file=.dockerconfigjson=./replicated-registry-auth.json
          kubectl -n redis-test create secret generic multi-namespace-yeti-redis-registry --type=kubernetes.io/dockerconfigjson --from-file=.dockerconfigjson=./replicated-registry-auth.json
          kubectl -n postgres-test create secret generic multi-namespace-yeti-registry --type=kubernetes.io/dockerconfigjson --from-file=.dockerconfigjson=./replicated-registry-auth.json
          kubectl -n default create secret generic multi-namespace-yeti-registry --type=kubernetes.io/dockerconfigjson --from-file=.dockerconfigjson=./replicated-registry-auth.json

          kustomize build $PWD/$APP_SLUG/overlays/midstream | kubectl apply -f -
          kustomize build $PWD/$APP_SLUG/overlays/midstream/charts/redis | kubectl apply -f -

          EXIT_CODE=$?
          if [ $EXIT_CODE -ne 0 ]; then
            echo "Failed to apply spec"
            echo "------pods:"
            kubectl get pods -A
            echo "------kotsadm logs"
            kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
            exit $EXIT_CODE
          fi

          echo "Waiting for pods to start"

          COUNTER=1
          while [ "$(kubectl get pods --no-headers | grep -v Running | grep -v Completed | wc -l)" -gt 0 ]; do
            COUNTER=$[$COUNTER +1]
            if [ $COUNTER -gt 120 ]; then
              echo "Timed out waiting for pods to start"
              kubectl get pods -A
              exit -1
            fi
            sleep 1
          done

          echo "All pods started"

      - name: Generate support bundle on failure
        if: failure()
        uses: ./.github/actions/generate-support-bundle
        with:
          kots-namespace: "$APP_NAME"
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-app-version-label:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.24.4-k3s1 ] # there's no need to run this test on multiple k3s versions
    env:
      APP_SLUG: app-version-label
      APP_VERSION_LABEL: v1.0.0
      LATEST_APP_VERSION_LABEL: v1.0.1
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - uses: replicatedhq/action-k3s@main
        with:
          version: ${{ matrix.k8s_version }}

      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/

      - run: chmod +x bin/kots

      - name: test kots install with version label
        run: |
          set +e
          echo ${{ secrets.APP_VERSION_LABEL_LICENSE }} | base64 -d > license.yaml
          ./bin/kots \
            install $APP_SLUG/automated \
            --license-file license.yaml \
            --app-version-label $APP_VERSION_LABEL \
            --no-port-forward \
            --namespace $APP_SLUG \
            --shared-password password \
            --kotsadm-registry ttl.sh \
            --kotsadm-namespace automated-${{ github.run_id }} \
            --kotsadm-tag 12h

          EXIT_CODE=$?
          if [ $EXIT_CODE -ne 0 ]; then
            echo "------pods:"
            kubectl -n $APP_SLUG get pods
            echo "------kotsadm logs"
            kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
            exit $EXIT_CODE
          fi

          COUNTER=1
          while [ "$(./bin/kots get apps --namespace $APP_SLUG | awk 'NR>1{print $3}')" != "$APP_VERSION_LABEL" ]; do
            COUNTER=$[$COUNTER +1]
            if [ $COUNTER -gt 120 ]; then
              echo "Timed out waiting for app to be installed with correct version label: $APP_VERSION_LABEL"
              ./bin/kots get apps --namespace $APP_SLUG
              echo "kotsadm logs:"
              kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
              exit -1
            fi
            sleep 1
          done

          printf "App is installed successfully with the correct version label: $APP_VERSION_LABEL\n\n"
          ./bin/kots get apps --namespace $APP_SLUG

          # test setting DockerHub credentials

          set +e

          # TODO: deploy and check secrets are actually created and images are pulled
          ./bin/kots docker ensure-secret --dockerhub-username replicatedtests --dockerhub-password ${{ secrets.DOCKERHUB_RATELIMIT_PASSWORD }} -n $APP_SLUG
          ./bin/kots download -n $APP_SLUG --slug $APP_SLUG
          if grep ${APP_SLUG}-kotsadm-dockerhub -w ./${APP_SLUG}/overlays/midstream/secret.yaml; then
            echo "Found DockerHub secret in ${APP_SLUG} latest version"
          else
            echo "No DockerHub secret found in appication namespace"
            exit -1
          fi

      - name: remove the app
        run: |
          set +e
          ./bin/kots remove $APP_SLUG --namespace $APP_SLUG --force

      - name: test kots install without version label
        run: |
          set +e
          echo ${{ secrets.APP_VERSION_LABEL_LICENSE }} | base64 -d > license.yaml
          ./bin/kots \
            install $APP_SLUG/automated \
            --license-file license.yaml \
            --no-port-forward \
            --namespace $APP_SLUG \
            --shared-password password \
            --kotsadm-registry ttl.sh \
            --kotsadm-namespace automated-${{ github.run_id }} \
            --kotsadm-tag 12h

          EXIT_CODE=$?
          if [ $EXIT_CODE -ne 0 ]; then
            echo "------pods:"
            kubectl -n $APP_SLUG get pods
            echo "------kotsadm logs"
            kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
            exit $EXIT_CODE
          fi

          COUNTER=1
          while [ "$(./bin/kots get apps --namespace $APP_SLUG | awk 'NR>1{print $3}')" != "$LATEST_APP_VERSION_LABEL" ]; do
            COUNTER=$[$COUNTER +1]
            if [ $COUNTER -gt 120 ]; then
              echo "Timed out waiting for app to be installed with latest version label: $LATEST_APP_VERSION_LABEL"
              ./bin/kots get apps --namespace $APP_SLUG
              echo "kotsadm logs:"
              kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
              exit -1
            fi
            sleep 1
          done

          printf "App is installed successfully with the correct version label: $LATEST_APP_VERSION_LABEL\n\n"
          ./bin/kots get apps --namespace $APP_SLUG

      - name: Generate support bundle on failure
        if: failure()
        uses: ./.github/actions/generate-support-bundle
        with:
          kots-namespace: "$APP_SLUG"
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-helm-install-order:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.21.8-k3s2,v1.22.5-k3s2,v1.23.3-k3s1,v1.24.4-k3s1 ]
    env:
      APP_SLUG: helm-install-order
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - uses: replicatedhq/action-k3s@main
        with:
          version: ${{ matrix.k8s_version }}

      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/

      - run: chmod +x bin/kots

      - name: run the test
        run: |
          set +e
          echo ${{ secrets.HELM_INSTALL_ORDER_LICENSE }} | base64 -d > license.yaml
          ./bin/kots \
            install $APP_SLUG/automated \
            --license-file license.yaml \
            --no-port-forward \
            --namespace $APP_SLUG \
            --shared-password password \
            --kotsadm-registry ttl.sh \
            --kotsadm-namespace automated-${{ github.run_id }} \
            --skip-preflights \
            --kotsadm-tag 12h

          EXIT_CODE=$?
          if [ $EXIT_CODE -ne 0 ]; then
            echo "------pods:"
            kubectl -n $APP_SLUG get pods
            echo "------kotsadm logs"
            kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
            exit $EXIT_CODE
          fi

          COUNTER=1
          while [ "$(./bin/kots get apps --namespace $APP_SLUG | awk 'NR>1{print $2}')" != "ready" ]; do
            COUNTER=$[$COUNTER +1]
            if [ $COUNTER -gt 120 ]; then
              echo "Timed out waiting for app to be ready"
              ./bin/kots get apps --namespace $APP_SLUG
              echo "kotsadm logs:"
              kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
              exit -1
            fi
            sleep 1
          done

          printf "App is installed successfully and is ready\n\n"
          ./bin/kots get apps --namespace $APP_SLUG

      - name: Generate support bundle on failure
        if: failure()
        uses: ./.github/actions/generate-support-bundle
        with:
          kots-namespace: "$APP_SLUG"
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-yamlescape:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.21.8-k3s2,v1.22.5-k3s2,v1.23.3-k3s1,v1.24.4-k3s1 ]
    env:
      APP_SLUG: yamlescape
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - uses: replicatedhq/action-k3s@main
        with:
          version: ${{ matrix.k8s_version }}

      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/

      - run: chmod +x bin/kots

      - name: run the test
        run: |
          set +e
          echo ${{ secrets.YAMLESCAPE_LICENSE }} | base64 -d > license.yaml
          ./bin/kots \
            install $APP_SLUG/automated \
            --license-file license.yaml \
            --no-port-forward \
            --namespace $APP_SLUG \
            --shared-password password \
            --kotsadm-registry ttl.sh \
            --kotsadm-namespace automated-${{ github.run_id }} \
            --skip-preflights \
            --kotsadm-tag 12h

          EXIT_CODE=$?
          if [ $EXIT_CODE -ne 0 ]; then
            echo "------pods:"
            kubectl -n $APP_SLUG get pods
            echo "------kotsadm logs"
            kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
            exit $EXIT_CODE
          fi

          COUNTER=1
          while [ "$(./bin/kots get apps --namespace $APP_SLUG | awk 'NR>1{print $2}')" != "ready" ]; do
            COUNTER=$[$COUNTER +1]
            if [ $COUNTER -gt 120 ]; then
              echo "Timed out waiting for app to be ready"
              ./bin/kots get apps --namespace $APP_SLUG
              echo "kotsadm logs:"
              kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
              exit -1
            fi
            sleep 1
          done

          printf "App is installed successfully and is ready\n\n"
          ./bin/kots get apps --namespace $APP_SLUG

      - name: Generate support bundle on failure
        if: failure()
        uses: ./.github/actions/generate-support-bundle
        with:
          kots-namespace: "$APP_SLUG"
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-no-redeploy-on-restart:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.24.4-k3s1 ]
    env:
      APP_SLUG: no-redeploy-on-restart
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - uses: replicatedhq/action-k3s@main
        with:
          version: ${{ matrix.k8s_version }}

      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/

      - run: chmod +x bin/kots

      - name: run the test
        run: |
          set +e
          echo ${{ secrets.NO_REDEPLOY_ON_RESTART_LICENSE }} | base64 -d > license.yaml
          ./bin/kots \
            install $APP_SLUG/automated \
            --license-file license.yaml \
            --no-port-forward \
            --namespace $APP_SLUG \
            --shared-password password \
            --kotsadm-registry ttl.sh \
            --kotsadm-namespace automated-${{ github.run_id }} \
            --skip-preflights \
            --kotsadm-tag 12h

          EXIT_CODE=$?
          if [ $EXIT_CODE -ne 0 ]; then
            echo "------pods:"
            kubectl -n $APP_SLUG get pods
            echo "------kotsadm logs"
            kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
            exit $EXIT_CODE
          fi

          # wait for application job to be created
          COUNTER=1
          while [ "$(kubectl get jobs -l app=example,component=job -n $APP_SLUG --ignore-not-found | awk 'NR>1' | wc -l)" == "0" ]; do
            COUNTER=$[$COUNTER +1]
            if [ $COUNTER -gt 60 ]; then
              echo "Timed out waiting for job to be created"
              exit -1
            fi
            sleep 1
          done

          # delete the application job and restart the admin console
          kubectl delete jobs -n $APP_SLUG --all
          kubectl delete pods -l app=kotsadm -n $APP_SLUG

          # wait for old kotsadm pod to terminate
          COUNTER=1
          while [ "$(kubectl get pods -l app=kotsadm -n $APP_SLUG | awk 'NR>1' | wc -l)" != "1" ]; do
            COUNTER=$[$COUNTER +1]
            if [ $COUNTER -gt 60 ]; then
              echo "More than 1 kotsadm pod found"
              exit -1
            fi
            sleep 1
          done

          # wait for new kotsadm pod to become ready
          kubectl wait --for=condition=ready pod -l app=kotsadm -n $APP_SLUG --timeout=60s

          # delay in case the app takes a bit to be deployed
          sleep 20

          # validate that the application wasn't re-deployed and the job wasn't re-created
          if [ "$(kubectl get jobs -l app=example,component=job -n $APP_SLUG --ignore-not-found | awk 'NR>1' | wc -l)" != "0" ]; then
              echo "App should not be re-deployed after restart"
              exit -1
          fi

          printf "Success. App was not re-deployed after restart\n\n"

      - name: Generate support bundle on failure
        if: failure()
        uses: ./.github/actions/generate-support-bundle
        with:
          kots-namespace: "$APP_SLUG"
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-kubernetes-installer-preflight:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.24.4-k3s1 ]
    env:
      APP_SLUG: kubernetes-installer-preflight
    steps:
      - uses: replicatedhq/action-k3s@main
        with:
          version: ${{ matrix.k8s_version }}

      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/

      - run: chmod +x bin/kots

      - name: run the test
        run: |
          set +e

          echo ${{ secrets.KUBERNETES_INSTALLER_PREFLIGHT_LICENSE }} | base64 -d > license.yaml

          # Fake kurl installation using the crd and installer spec from the application manifests:

          # Pull application manifests
          ./bin/kots pull $APP_SLUG/automated --license-file license.yaml --shared-password password

          # Apply installer crd
          kubectl apply -f $APP_SLUG/upstream/installer-crd.yaml

          # Wait for crd to be created
          kubectl wait --for condition=established --timeout=60s crd/installers.cluster.kurl.sh

          # Seems that the above does not always guarantee the crd exists? So just in case...
          sleep 10

          # Apply installer
          kubectl apply -f $APP_SLUG/upstream/installer.yaml

          # Create kurl-config configmap in kube-system
          kubectl create cm kurl-config -n kube-system --from-literal=installer_id=my-installer

          ./bin/kots \
            install $APP_SLUG/automated \
            --license-file license.yaml \
            --no-port-forward \
            --namespace $APP_SLUG \
            --shared-password password \
            --kotsadm-registry ttl.sh \
            --kotsadm-namespace automated-${{ github.run_id }} \
            --kotsadm-tag 12h

          EXIT_CODE=$?
          if [ $EXIT_CODE -ne 0 ]; then
            echo "------pods:"
            kubectl -n $APP_SLUG get pods
            echo "------kotsadm logs"
            kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
            exit $EXIT_CODE
          fi

          # validate that preflight checks ran
          JSON_PATH="jsonpath={.data['automated-install-slug-$APP_SLUG']}"
          if [ "$(kubectl get cm kotsadm-tasks -n $APP_SLUG -o $JSON_PATH | grep -c pending_preflight)" != "1" ]; then
              echo "Preflight checks did not run"
              exit -1
          fi

          COUNTER=1
          while [ "$(./bin/kots get apps --namespace $APP_SLUG | awk 'NR>1{print $2}')" != "ready" ]; do
            COUNTER=$[$COUNTER +1]
            if [ $COUNTER -gt 120 ]; then
              echo "Timed out waiting for app to be ready"
              ./bin/kots get apps --namespace $APP_SLUG
              echo "kotsadm logs:"
              kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
              exit -1
            fi
            sleep 1
          done

          # try get apps without namespace (using kubeconfig)
          # validate that output is the same as above
          mkdir -p /tmp/.kube
          sudo cp /tmp/output/kubeconfig-v1.24.4-k3s1.yaml /tmp/.kube/config
          sudo chmod -R 777 /tmp/.kube
          export KUBECONFIG=/tmp/.kube/config
          kubectl config set-context --current --namespace=$APP_SLUG
          if [ "$(./bin/kots get apps | awk 'NR>1{print $2}')" != "ready" ]; then
              echo "kots get apps output is not the same as above"
              exit -1
          fi

          printf "App is installed successfully and is ready\n\n"
          ./bin/kots get apps --namespace $APP_SLUG

      - name: Generate support bundle on failure
        if: failure()
        uses: ./.github/actions/kots-e2e
        with:
          kots-namespace: "$APP_SLUG"
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-tag-and-digest:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-e2e, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.24.4-k3s1 ]
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: download e2e deps
        uses: actions/download-artifact@v2
        with:
          name: e2e
          path: e2e/bin/
      - run: docker load -i e2e/bin/e2e-deps.tar
      - run: chmod +x e2e/bin/*
      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/
      - run: chmod +x bin/*
      - uses: ./.github/actions/kots-e2e
        with:
          test-focus: 'Tag and Digest'
          kots-namespace: 'tag-and-digest'
          k8s-version: '${{ matrix.k8s_version }}'
          testim-access-token: '${{ secrets.TESTIM_ACCESS_TOKEN }}'
          testim-branch: ${{ github.head_ref == 'main' && 'master' || github.head_ref }}
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-kots-push-images-anonymous:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/

      - run: chmod +x bin/kots

      - name: run kots admin-console push-images
        run: |
          set +e
          ./bin/kots admin-console push-images ./hack/tests/small.airgap ttl.sh/automated-${{ github.run_id }}


  validate-min-kots-version:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-e2e, build-kots, build-kurl-proxy, build-migrations, push-minio, push-rqlite, generate-tag ]
    env:
      APP_SLUG: min-kots-version
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [v1.25.0-k3s1]
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: download e2e deps
        uses: actions/download-artifact@v2
        with:
          name: e2e
          path: e2e/bin/
      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/
      - run: |
          docker load -i e2e/bin/e2e-deps.tar
          chmod +x e2e/bin/*
          chmod +x bin/*
          cp ./bin/kots /usr/local/bin/kubectl-kots
          sudo apt-get update -y && sudo apt-get install jq -y
      - uses: ./.github/actions/kots-e2e
        with:
          test-focus: 'Min KOTS Version'
          kots-namespace: 'min-kots-version'
          k8s-version: '${{ matrix.k8s_version }}'
          testim-access-token: '${{ secrets.TESTIM_ACCESS_TOKEN }}'
          testim-branch: ${{ github.head_ref == 'main' && 'master' || github.head_ref }}
          kotsadm-image-registry: ttl.sh
          kotsadm-namespace: automated-${{ github.run_id }}
          kotsadm-tag: 12h
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'

      - name: validate that kots install fails early
        run: |
          set +e

          result=$(kubectl kots install $APP_SLUG/automated --no-port-forward --namespace $APP_SLUG --shared-password password 2>&1 >/dev/null)
          echo "$result"

          if [[ "$result" =~ "requires" ]] && [[ "$result" =~ "10000.0.0" ]]; then
            exit 0
          else
            exit 1
          fi


  validate-target-kots-version:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-e2e, build-kots, build-kurl-proxy, build-migrations, push-minio, push-rqlite, generate-tag ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [v1.25.0-k3s1]
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: download e2e deps
        uses: actions/download-artifact@v2
        with:
          name: e2e
          path: e2e/bin/
      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/
      - run: |
          docker load -i e2e/bin/e2e-deps.tar
          chmod +x e2e/bin/*
          chmod +x bin/*
          cp ./bin/kots /usr/local/bin/kubectl-kots
          sudo apt-get update -y && sudo apt-get install jq -y
      - uses: ./.github/actions/kots-e2e
        with:
          test-focus: 'Target KOTS Version'
          kots-namespace: 'target-kots-version'
          k8s-version: '${{ matrix.k8s_version }}'
          testim-access-token: '${{ secrets.TESTIM_ACCESS_TOKEN }}'
          testim-branch: ${{ github.head_ref == 'main' && 'master' || github.head_ref }}
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'
      - name: validate that kots install fails early
        run: |
          set +e

          result=$(kubectl kots install target-kots-version/automated --no-port-forward --namespace target-kots-version --shared-password password 2>&1 >/dev/null)
          echo "$result"

          if [[ "$result" =~ "requires" ]] && [[ "$result" =~ "1.0.0" ]]; then
            exit 0
          else
            exit 1
          fi


  validate-range-kots-version:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-e2e, build-kots, build-kurl-proxy, build-migrations, push-minio, push-rqlite, generate-tag ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [v1.25.0-k3s1]
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: download e2e deps
        uses: actions/download-artifact@v2
        with:
          name: e2e
          path: e2e/bin/
      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/
      - run: |
          docker load -i e2e/bin/e2e-deps.tar
          chmod +x e2e/bin/*
          chmod +x bin/*
          cp ./bin/kots /usr/local/bin/kubectl-kots
          sudo apt-get update -y && sudo apt-get install jq -y
      - uses: ./.github/actions/kots-e2e
        with:
          test-focus: 'Range KOTS Version'
          kots-namespace: 'range-kots-version'
          k8s-version: '${{ matrix.k8s_version }}'
          testim-access-token: '${{ secrets.TESTIM_ACCESS_TOKEN }}'
          testim-branch: ${{ github.head_ref == 'main' && 'master' || github.head_ref }}
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'
      - name: validate that kots install fails early
        run: |
          set +e

          result=$(kubectl kots install range-kots-version/automated --no-port-forward --namespace range-kots-version --shared-password password 2>&1 >/dev/null)
          echo "$result"

          if [[ "$result" =~ "requires" ]] && [[ "$result" =~ "11000.0.0" ]]; then
            exit 0
          else
            exit 1
          fi


  validate-postgres-to-rqlite-migration:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.21.8-k3s2,v1.22.5-k3s2,v1.23.3-k3s1,v1.24.4-k3s1 ]
    env:
      APP_SLUG: postgres-to-rqlite
      BASE_KOTS_VERSION: v1.57.0
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - uses: replicatedhq/action-k3s@main
        with:
          version: ${{ matrix.k8s_version }}

      - name: download base kots version
        run: |
          curl -LO https://github.com/replicatedhq/kots/releases/download/$BASE_KOTS_VERSION/kots_linux_amd64.tar.gz \
            && tar zxvf kots_linux_amd64.tar.gz \
            && mv kots kots-$BASE_KOTS_VERSION

      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/

      - run: chmod +x bin/kots

      - name: run the test
        run: |
          set +e
          echo ${{ secrets.POSTGRES_TO_RQLITE_LICENSE }} | base64 -d > license.yaml

          # install using the base KOTS version

          ./kots-$BASE_KOTS_VERSION \
            install $APP_SLUG/automated \
            --license-file license.yaml \
            --port-forward=false \
            --namespace $APP_SLUG \
            --shared-password password

          EXIT_CODE=$?
          if [ $EXIT_CODE -ne 0 ]; then
            echo "------pods:"
            kubectl -n $APP_SLUG get pods
            echo "------kotsadm logs"
            kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
            exit $EXIT_CODE
          fi

          COUNTER=1
          while [ "$(./kots-$BASE_KOTS_VERSION get apps --namespace $APP_SLUG | awk 'NR>1{print $2}')" != "ready" ]; do
            COUNTER=$[$COUNTER +1]
            if [ $COUNTER -gt 120 ]; then
              echo "Timed out waiting for app to be ready"
              ./kots-$BASE_KOTS_VERSION get apps --namespace $APP_SLUG
              echo "kotsadm logs:"
              kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
              exit -1
            fi
            sleep 1
          done

          # upgrade using the new KOTS version

          ./bin/kots admin-console upgrade \
            --namespace $APP_SLUG \
            --kotsadm-registry ttl.sh \
            --kotsadm-namespace automated-${{ github.run_id }} \
            --kotsadm-tag 12h

          if ! kubectl logs -l app=kotsadm --namespace $APP_SLUG | grep -q "Migrated from Postgres to rqlite successfully"; then
            echo "Failed to find a successful migration log line"
            echo "kotsadm logs:"
            kubectl logs -l app=kotsadm --all-containers --namespace $APP_SLUG
            exit 1
          fi

          # make sure app is still installed and ready

          if [ "$(./bin/kots get apps --namespace $APP_SLUG | awk 'NR>1{print $2}')" != "ready" ]; then
            echo "App is not ready after the upgrade"
            echo "kotsadm logs:"
            kubectl logs -l app=kotsadm --tail=100 --namespace $APP_SLUG
            exit 1
          fi

          printf "App is still installed and is ready after the migration\n\n"
          ./bin/kots get apps --namespace $APP_SLUG

      - name: Generate support bundle on failure
        if: failure()
        uses: ./.github/actions/generate-support-bundle
        with:
          kots-namespace: "$APP_SLUG"
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'

  validate-multi-app-install:
    runs-on: ubuntu-20.04
    needs: [ enable-tests, can-run-ci, build-kots, build-e2e, build-kurl-proxy, build-migrations, push-minio, push-rqlite ]
    strategy:
      fail-fast: false
      matrix:
        k8s_version: [ v1.24.4-k3s1 ] # there's no need to run this test on multiple k3s versions
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: download e2e deps
        uses: actions/download-artifact@v2
        with:
          name: e2e
          path: e2e/bin/
      - run: docker load -i e2e/bin/e2e-deps.tar
      - run: chmod +x e2e/bin/*
      - name: download kots binary
        uses: actions/download-artifact@v2
        with:
          name: kots
          path: bin/
      - run: chmod +x bin/*
      - uses: ./.github/actions/kots-e2e
        with:
          test-focus: 'multi-app-install'
          kots-namespace: 'multi-app-install'
          k8s-version: '${{ matrix.k8s_version }}'
          testim-access-token: '${{ secrets.TESTIM_ACCESS_TOKEN }}'
          testim-branch: ${{ github.head_ref == 'main' && 'master' || github.head_ref }}
          aws-access-key-id: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_ACCESS_KEY_ID }}'
          aws-secret-access-key: '${{ secrets.E2E_SUPPORT_BUNDLE_AWS_SECRET_ACCESS_KEY }}'


  validate-pr-tests:
    runs-on: ubuntu-20.04
    needs:
      # testim tests
      - validate-existing-online-install-minimal
      - validate-smoke-test
      - validate-minimal-rbac
      - validate-backup-and-restore
      - validate-no-required-config
      - validate-version-history-pagination
      - validate-change-license
      - validate-helm-managed
      - validate-tag-and-digest
      - validate-min-kots-version
      - validate-target-kots-version
      - validate-range-kots-version
      - validate-multi-app-install
      # non-testim tests
      - validate-minimal-rbac-override
      - validate-multi-namespace
      - validate-kots-pull
      - validate-app-version-label
      - validate-strict-preflight-checks
      - validate-helm-install-order
      - validate-yamlescape
      - validate-no-redeploy-on-restart
      - validate-kubernetes-installer-preflight
      - validate-postgres-to-rqlite-migration
      # cli-only tests
      - validate-kots-push-images-anonymous
    steps:
      - run: echo "All PR tests passed"

  # this job will validate that the kurl add-on validation did not fail and that all pr-tests succeed
  # it is used for the github branch protection rule
  validate-success:
    runs-on: ubuntu-20.04
    needs:
      - validate-kurl-addon
      - validate-pr-tests
    if: always()
    steps:
      # https://docs.github.com/en/actions/learn-github-actions/contexts#needs-context
      # if the validate-kurl-addon job failed or was cancelled, this job will fail. it's ok if this job was skipped
      - name: fail if validate-kurl-addon job failed
        if: needs.validate-kurl-addon.result == 'failure' || needs.validate-kurl-addon.result == 'cancelled'
        run: exit 1
      # if the validate-pr-tests job was not successful, this job will fail
      - name: fail if validate-pr-tests job was not successful
        if: needs.validate-pr-tests.result != 'success'
        run: exit 1
      # if the validate-pr-tests job was successful, this job will succeed
      - name: succeed if validate-pr-tests job succeeded
        if: needs.validate-pr-tests.result == 'success'
        run: echo "Validation succeeded"
